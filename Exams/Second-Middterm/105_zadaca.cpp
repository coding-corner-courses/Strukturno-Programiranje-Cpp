#include <iostream>

using namespace std;

//Задача 5 - Дополнителни задачи за вежбање
//Еден елемент се заматува ако се најде аритметичка средина на елементот и сите негови соседи. 
//Сосед на еден елемент се сите елементи кои припаѓаат на матрицата и се  околу истиот елемент (хоризонтално, вертикално и дијагонално). 
//
//Од стандарден влез се чита матрица од реални броеви (3 < n,m < 50). 
//Прво се читаат бројот на редици и колони на матрицата и во секој преостанат ред се внесува еден ред од матрицата (види пример).
//По читањето на матрицата, се внесуваат и 2 пара координати на матрицата (ред и колона) кои го репрезентираат горниот-лев и долниот-десен елемент од регионот. 
//Потребно е да генеирате нова матрица во која ќе ги заматите сите елементи кои припаѓаат на регионот. 
//Новодобиената матрица, во истиот формат, треба да се испечати (види пример).
//
//Пример:
//
//3 4
//1.00 2.00 3.00 4.00
//5.00 6.00 7.00 8.00
//9.00 0.00 1.00 2.00
//0 1
//2 2
//Резултат:
//
//3 4
//1.00 4.00 5.00 4.00
//5.00 3.78 3.67 8.00
//9.00 4.67 4.00 2.00

int main() {
    int n, m;
    cin >> n >> m;
    int ki1, kj1, ki2, kj2;

    float matrix[50][50];
    float transformedMatrix[50][50];

    // Пополнување на матрицата
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            float number;
            cin >> number;
            matrix[i][j] = number;
        }
    }
    
        cin >> ki1 >> kj1 >> ki2 >> kj2;


    // Пополнување на трансформираната матрица пред да бидат трансформирани елементите
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            transformedMatrix[i][j] = matrix[i][j];
        }
    }

    // Изминување на елементите кои треба да се замаглени  
    for (int i = ki1; i <= ki2 && i<n; i++) { 
        for (int j = kj1; j <= kj2 && j<m; j++) {
            float sum = matrix[i][j];
            int counter = 1;
            
            // Проверка за елемент горе лево
            if (i - 1 >= 0 && j - 1 >= 0) {
                sum += matrix[i - 1][j - 1];
                counter++;
            }

            // Проверка за елемент горе
            if (i - 1 >= 0) {
                sum += matrix[i - 1][j];
                counter++;
            }

            // Проверка за елемент горе десно
            if (i - 1 >= 0 && j + 1 < m) {
                sum += matrix[i - 1][j + 1];
                counter++;
            }

            // Проверка за елемент лево
            if (j - 1 >= 0) {
                sum += matrix[i][j - 1];
                counter++;
            }

            // Проверка за елемент десно
            if (j + 1 < m) {
                sum += matrix[i][j + 1];
                counter++;
            }

            // Проверка за елемент долу лево
            if (i + 1 < n && j - 1 >= 0) {
                sum += matrix[i + 1][j - 1];
                counter++;
            }

            // Проверка за елемент долу
            if (i + 1 < n) {
                sum += matrix[i + 1][j];
                counter++;
            }

            // Проверка за елемент долу десно
            if (i + 1 < n && j + 1 < m) {
                sum += matrix[i + 1][j + 1];
                counter++;
            }

            float avg = sum / counter*1.0;
            transformedMatrix[i][j] = avg;
        }
    }

    // Печатење на трансформирана матрица
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cout << transformedMatrix[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}
